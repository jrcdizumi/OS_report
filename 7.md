# Lab7 Report

***
## 练习1

理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

**信号量结构体(kern/sync/sem.h)**

```c
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```
`valve`：当前信号量的值：
    valve>0表示资源还有空闲，且valve的值就是空闲资源数量；
    valve==0表示资源无空闲；
    valve<0表示目前有线程在等待资源，且valve的值为等待队列长度。
`wait_queue`：等待队列。

**基于管程的哲学家就餐问题`check_sync`函数(kern/sync/check_sync.c)**

```c
void check_sync(void){

    int i;

    //check semaphore
    sem_init(&mutex, 1);
    for(i=0;i<N;i++){
        sem_init(&s[i], 0);
        int pid = kernel_thread(philosopher_using_semaphore, (void *)i, 0);
        if (pid <= 0) {
            panic("create No.%d philosopher_using_semaphore failed.\n");
        }
        philosopher_proc_sema[i] = find_proc(pid);
        set_proc_name(philosopher_proc_sema[i], "philosopher_sema_proc");
    }
    ...
}
```
该check函数调用了kernel_thread来创建一个哲学家就餐问题的内核线程。
`kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags)`：
传入的参数：
- `philosopher_using_semaphore`： 线程执行的函数，这里传入的是信号量实现的哲学家就餐问题的实现函数
- `i`：哲学家的编号，传给`philosopher_using_semaphore`的参数；
- `0`：共享内存标记位。内核线程之间内存共享，故设置为0。

**`philosopher_using_semaphore`函数(kern/sync/check_sync.c)**
```c
int philosopher_using_semaphore(void * arg)
{
    int i, iter=0;
    i=(int)arg;
    cprintf("I am No.%d philosopher_sema\n",i);
    while(iter++<TIMES)
    {
        cprintf("Iter %d, No.%d philosopher_sema is thinking\n",iter,i);
        do_sleep(SLEEP_TIME);//思考一段时间
        phi_take_forks_sema(i); //拿两只叉子，或者阻塞等待叉子
        cprintf("Iter %d, No.%d philosopher_sema is eating\n",iter,i);
        do_sleep(SLEEP_TIME);//开吃一段时间
        phi_put_forks_sema(i); //把两把叉子同时放回桌子
    }
    cprintf("No.%d philosopher_sema quit\n",i);
    return 0;
}
```

**`phi_take_forks_sema`函数(kern/sync/check_sync.c)**
```c
void phi_take_forks_sema(int i) //拿叉子
{ 
        down(&mutex); //信号量>0则信号量--；否则阻塞；这里用于互斥访问state_sema
        state_sema[i]=HUNGRY; //标记该哲学家状态为饥饿
        phi_test_sema(i); //尝试就餐
        up(&mutex); //放开state_sema的访问权限
        down(&s[i]); //如果可以就餐则s[i]>0，不阻塞；如果拿不到叉子就阻塞
}
```
**`phi_put_forks_sema`函数(kern/sync/check_sync.c)**
```c
void phi_put_forks_sema(int i) //放叉子
{ 
        down(&mutex); //信号量>0则信号量--；否则阻塞；这里用于互斥访问state_sema
        state_sema[i]=THINKING; //标记该哲学家状态为思考
        phi_test_sema(LEFT); //尝试让左边的哲学家就餐
        phi_test_sema(RIGHT); //尝试让右边的哲学家就餐
        up(&mutex); //放开state_sema的访问权限
}
```

**`phi_test_sema`函数(kern/sync/check_sync.c)**
```c
void phi_test_sema(i) 
{ 
    if(state_sema[i]==HUNGRY&&state_sema[LEFT]!=EATING
            &&state_sema[RIGHT]!=EATING)
    {
        state_sema[i]=EATING;//如果左右的哲学家都没在就餐则可以开吃
        up(&s[i]);//可以就餐则s[i]++
    }
}
```

**信号量的具体功能实现(kern/sync/sem.c)**

- 信号量的初始化：
```c
void
sem_init(semaphore_t *sem, int value) {
    sem->value = value;
    wait_queue_init(&(sem->wait_queue));
}
```

- `up`函数：
```c
static __noinline void __up(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        wait_t *wait;
        if ((wait = wait_queue_first(&(sem->wait_queue))) == NULL) {
            sem->value ++;
        }
        else {
            assert(wait->proc->wait_state == wait_state);
            wakeup_wait(&(sem->wait_queue), wait, wait_state, 1);
        }
    }
    local_intr_restore(intr_flag);
}
```
实现原理：
先关中断，如果信号量对应的`wait_queue`中没有进程在等待，信号量`value++`；如果有进程在等待，则调用`wakeup_wait`函数唤醒`wait_queue`中等待的第一个wait并将其从`wait_queue`中删除，最后开中断返回。

- `down`函数：
```c
static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    if (sem->value > 0) {
        sem->value --;
        local_intr_restore(intr_flag);
        return 0;
    }
    wait_t __wait, *wait = &__wait;
    wait_current_set(&(sem->wait_queue), wait, wait_state);
    local_intr_restore(intr_flag);

    schedule();

    local_intr_save(intr_flag);
    wait_current_del(&(sem->wait_queue), wait);
    local_intr_restore(intr_flag);

    if (wait->wakeup_flags != wait_state) {
        return wait->wakeup_flags;
    }
    return 0;
}
```
实现原理：
先关中断，如果当前信号量的`value>0`则`value--`，并打开中断返回；如果`valve<=0`，则将当前的进程加入到等待队列中，并打开中断，运行调度器选择另外一个进程执行。如果`value>0`被`wakeup_wait`唤醒，则把自身关联的`wait`从等待队列中删除。

***
## 练习2

完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### 内核级条件变量的设计(kern/sync/monitor.h)

**管程机制**
管程（Monitor）是一种操作系统中的同步机制，它的引入是为了解决多线程或多进程环境下的并发控制问题。

在传统的操作系统中，当多个进程或线程同时访问共享资源时，可能会导致数据的不一致性、竞态条件和死锁等问题。为了避免这些问题，需要引入一种同步机制来协调并发访问。

管程提供了一种高级的同步原语，它将共享资源和对资源的操作封装在一个单元中，并提供了对这个单元的访问控制机制。

一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。管程由四部分组成：
- 管程内部的共享变量；
- 管程内部的条件变量；
- 管程内部并发执行的进程；
- 对管程内部的共享数据设置初始值的语句。
定义的数据结构如下：
```c
typedef struct monitor{
    semaphore_t mutex;      // the mutex lock for going into the routines in monitor, should be initialized to 1
    semaphore_t next;       // the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.
    int next_count;         // the number of of sleeped signaling proc
    condvar_t *cv;          // the condvars in monitor
} monitor_t;
```

**条件变量**

条件变量两种操作如下：
- wait_cv： 被一个进程调用,以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时,不被认为是占用了管程。如果条件不能满足，就需要等待。
- signal_cv：被一个进程调用,以指出断言Pc现在为真,从而可以唤醒等待断言Pc被满足的进程继续执行。如果条件可以满足，那么可以运行。

定义的数据结构如下：
```c
typedef struct condvar{
    semaphore_t sem;        
    int count;              // the number of waiters on condvar
    monitor_t * owner;      // the owner(monitor) of this condvar
} condvar_t;
```

**实现`cond_signal`函数**
```c
void 
cond_signal (condvar_t *cvp) {
    cprintf("cond_signal begin: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);  
    if (cvp->count>0) {
        cvp->owner->next_count ++; //管程中睡眠的数量++
        up(&(cvp->sem)); //唤醒在条件变量里睡眠的进程
        down(&(cvp->owner->next)); //将在管程中的进程睡眠
        cvp->owner->next_count--; //管程中睡眠的进程数量--
    }
    cprintf("cond_signal end: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
}
```
如果`cvp.count<=0`，则表示当前没有睡眠在这一个条件变量上的进程，也就没有需要唤醒的进程，直接函数返回即可。
如果`cvp.count>0`，这表示当前有睡眠在该条件变量上的进程，因此需要唤醒等待在`cv.sem`上睡眠的进程。而由于只允许一个进程在管程中执行，所以一旦进程B唤醒了别人（进程A），那么自己就需要睡眠。故`monitor.next_count++`，且让自己（进程B）睡在信号量monitor.next（宿主管程的信号量）上。如果睡醒了则`monitor.next_count--`。

**实现`cond_wait`函数**
```c
void
cond_wait (condvar_t *cvp) {
    cprintf("cond_wait begin:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
    cvp->count ++;
    if (cvp->owner->next_count>0)
        up(&(cvp->owner->next));
    else
        up(&(cvp->owner->mutex));
    down(&(cvp->sem));
    cvp->count --;
    cprintf("cond_wait end:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
}
```
如果`monitor.next_count>0`，表示有大于等于1个进程执行`cond_signal`函数且睡着了，就睡在了`monitor.next`信号量上。唤醒睡在`monitor.next`上的一个进程B。然后进程A睡在`cv.sem`上，如果睡醒了，则让`cv.count`减一，表示等待此条件的睡眠进程个数少了一个。
如果`monitor.next_count<=0`，表示目前没有进程执行`cond_signal`函数且睡着了，那需要唤醒的是由于互斥条件限制而无法进入管程的进程，所以要唤醒睡在`monitor.mutex`上的进程。然后进程A睡在`cv.sem`上，如果睡醒了，则让`cv.count`减一，表示等待此条件的睡眠进程个数少了一个。

### 用管程机制实现哲学家就餐问题

**观察`philosopher_using_condvar`函数**
```c
int philosopher_using_condvar(void * arg) { /* arg is the No. of philosopher 0~N-1*/
  
    int i, iter=0;
    i=(int)arg;
    cprintf("I am No.%d philosopher_condvar\n",i);
    while(iter++<TIMES)
    { /* iterate*/
        cprintf("Iter %d, No.%d philosopher_condvar is thinking\n",iter,i); /* thinking*/
        do_sleep(SLEEP_TIME);
        phi_take_forks_condvar(i); 
        /* need two forks, maybe blocked */
        cprintf("Iter %d, No.%d philosopher_condvar is eating\n",iter,i); /* eating*/
        do_sleep(SLEEP_TIME);
        phi_put_forks_condvar(i); 
        /* return two forks back*/
    }
    cprintf("No.%d philosopher_condvar quit\n",i);
    return 0;    
}
```
和信号量实现的`philosopher_using_semaphore`函数基本没有什么区别。

**实现`phi_take_forks_condvar`函数**
```c
void phi_take_forks_condvar(int i) {
     down(&(mtp->mutex));
//--------into routine in monitor--------------
    // LAB7 EXERCISE1: YOUR CODE
    // I am hungry
    state_condvar[i] = HUNGRY;
    // try to get fork
      phi_test_condvar(i);		//测试哲学家是否能拿到筷子
      while (state_condvar[i] != EATING) {	//没拿到，需要等待，调用wait函数
          cprintf("phi_take_forks_condvar: %d didn't get fork and will wait\n",i);
          cond_wait(&mtp->cv[i]);
      }
//--------leave routine in monitor--------------
      if(mtp->next_count>0)
         up(&(mtp->next));
      else
         up(&(mtp->mutex));
}
```
**实现`phi_put_forks_condvar`函数**
```c
void phi_put_forks_condvar(int i) {
     down(&(mtp->mutex));

//--------into routine in monitor--------------
     // LAB7 EXERCISE1: YOUR CODE
     // I ate over
     cprintf("phi_put_forks_condvar: state_condvar[%d] will thinking\n",i);
     state_condvar[i] = THINKING;
     // test left and right neighbors
     phi_test_condvar(LEFT); //尝试让左边的吃
     phi_test_condvar(RIGHT); //尝试让右边的吃
//--------leave routine in monitor--------------
     if(mtp->next_count>0)
        up(&(mtp->next));
     else
        up(&(mtp->mutex));
}
```
**给用户态进程/线程提供信号量机制和给内核级提供信号量机制的异同**

- 异：在用户态使用信号量时，需要进行系统调用进入到内核态进行操作；
- 同：用户态的进程的信号量的数据结构和内核级的是一样的；用户态在使用这个信号量时，通过P操作与V操作，也是通过系统调用进入到内核中进行处理。

**能否不用基于信号量机制来完成条件变量？**

可以模仿信号量的实现，通过开关中断来完成cond_wait和cond_signal的原子性。(相当于自己在条件变量内部实现和信号量相同的机制，也就是自己实现一个信号量)