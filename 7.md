# Lab7 Report

***
## 练习1

理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

**信号量结构体(kern/sync/sem.h)**

```c
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```
`valve`：当前信号量的值：
    valve>0表示资源还有空闲，且valve的值就是空闲资源数量；
    valve==0表示资源无空闲；
    valve<0表示目前有线程在等待资源，且valve的值为等待队列长度。
`wait_queue`：等待队列。

**基于管程的哲学家就餐问题`check_sync`函数(kern/sync/check_sync.c)**

```c
void check_sync(void){

    int i;

    //check semaphore
    sem_init(&mutex, 1);
    for(i=0;i<N;i++){
        sem_init(&s[i], 0);
        int pid = kernel_thread(philosopher_using_semaphore, (void *)i, 0);
        if (pid <= 0) {
            panic("create No.%d philosopher_using_semaphore failed.\n");
        }
        philosopher_proc_sema[i] = find_proc(pid);
        set_proc_name(philosopher_proc_sema[i], "philosopher_sema_proc");
    }
    ...
}
```
该check函数调用了kernel_thread来创建一个哲学家就餐问题的内核线程。
`kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags)`：
传入的参数：
- `philosopher_using_semaphore`： 线程执行的函数，这里传入的是信号量实现的哲学家就餐问题的实现函数
- `i`：哲学家的编号，传给`philosopher_using_semaphore`的参数；
- `0`：共享内存标记位。内核线程之间内存共享，故设置为0。

**`philosopher_using_semaphore`函数(kern/sync/check_sync.c)**
```c
int philosopher_using_semaphore(void * arg)
{
    int i, iter=0;
    i=(int)arg;
    cprintf("I am No.%d philosopher_sema\n",i);
    while(iter++<TIMES)
    {
        cprintf("Iter %d, No.%d philosopher_sema is thinking\n",iter,i);
        do_sleep(SLEEP_TIME);//思考一段时间
        phi_take_forks_sema(i); //拿两只叉子，或者阻塞等待叉子
        cprintf("Iter %d, No.%d philosopher_sema is eating\n",iter,i);
        do_sleep(SLEEP_TIME);//开吃一段时间
        phi_put_forks_sema(i); //把两把叉子同时放回桌子
    }
    cprintf("No.%d philosopher_sema quit\n",i);
    return 0;
}
```

**`phi_take_forks_sema`函数(kern/sync/check_sync.c)**
```c
void phi_take_forks_sema(int i) //拿叉子
{ 
        down(&mutex); //信号量>0则信号量--；否则阻塞；这里用于互斥访问state_sema
        state_sema[i]=HUNGRY; //标记该哲学家状态为饥饿
        phi_test_sema(i); //尝试就餐
        up(&mutex); //放开state_sema的访问权限
        down(&s[i]); //如果可以就餐则s[i]>0，不阻塞；如果拿不到叉子就阻塞
}
```
**`phi_put_forks_sema`函数(kern/sync/check_sync.c)**
```c
void phi_put_forks_sema(int i) //放叉子
{ 
        down(&mutex); //信号量>0则信号量--；否则阻塞；这里用于互斥访问state_sema
        state_sema[i]=THINKING; //标记该哲学家状态为思考
        phi_test_sema(LEFT); //尝试让左边的哲学家就餐
        phi_test_sema(RIGHT); //尝试让右边的哲学家就餐
        up(&mutex); //放开state_sema的访问权限
}
```

**`phi_test_sema`函数(kern/sync/check_sync.c)**
```c
void phi_test_sema(i) 
{ 
    if(state_sema[i]==HUNGRY&&state_sema[LEFT]!=EATING
            &&state_sema[RIGHT]!=EATING)
    {
        state_sema[i]=EATING;//如果左右的哲学家都没在就餐则可以开吃
        up(&s[i]);//可以就餐则s[i]++
    }
}
```

**信号量的具体功能实现(kern/sync/sem.c)**

- 信号量的初始化：
```c
void
sem_init(semaphore_t *sem, int value) {
    sem->value = value;
    wait_queue_init(&(sem->wait_queue));
}
```

- `up`函数：
```c
static __noinline void __up(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        wait_t *wait;
        if ((wait = wait_queue_first(&(sem->wait_queue))) == NULL) {
            sem->value ++;
        }
        else {
            assert(wait->proc->wait_state == wait_state);
            wakeup_wait(&(sem->wait_queue), wait, wait_state, 1);
        }
    }
    local_intr_restore(intr_flag);
}
```
实现原理：
先关中断，如果信号量对应的`wait_queue`中没有进程在等待，信号量`value++`；如果有进程在等待，则调用`wakeup_wait`函数唤醒`wait_queue`中等待的第一个wait并将其从`wait_queue`中删除，最后开中断返回。

- `down`函数：
```c
static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
    if (sem->value > 0) {
        sem->value --;
        local_intr_restore(intr_flag);
        return 0;
    }
    wait_t __wait, *wait = &__wait;
    wait_current_set(&(sem->wait_queue), wait, wait_state);
    local_intr_restore(intr_flag);

    schedule();

    local_intr_save(intr_flag);
    wait_current_del(&(sem->wait_queue), wait);
    local_intr_restore(intr_flag);

    if (wait->wakeup_flags != wait_state) {
        return wait->wakeup_flags;
    }
    return 0;
}
```
实现原理：
先关中断，如果当前信号量的`value>0`则`value--`，并打开中断返回；如果`valve<=0`，则将当前的进程加入到等待队列中，并打开中断，运行调度器选择另外一个进程执行。如果`value>0`被`wakeup_wait`唤醒，则把自身关联的`wait`从等待队列中删除。

***
## 练习2

完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### 内核级条件变量的设计

### 用管程机制实现哲学家就餐问题

