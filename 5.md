# Lab5 Report

***
## 练习1

`do_execv`函数调用`load_icode`（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量`trapframe`中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的`trapframe`内容。

实验所需填充的代码段主要作用为：
重新设置进程的中断帧，使得在执行中断返回指令`iret`后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断。
具体代码如下：

```c
static int load_icode(unsigned char *binary, size_t size) {
    ...
    tf->tf_cs = USER_CS;//将tf_cs设置为用户态
    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;//tf_ds=tf_es=tf_ss设置为用户态
    tf->tf_esp = USTACKTOP;//将esp设置为用户栈的栈顶。
    tf->tf_eip = elf->e_entry;//eip指向程序的入口，即elf中的e_entry
    tf->tf_eflags = tf->tf_eflags | FL_IF;//允许中断产生
    ret = 0;
    ...
}
```

***
## 练习2

创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

我们的代码只需实现将父进程的内存直接复制给子进程（调用一个memcpy即可）。

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
	...
        uintptr_t kva_src = page2kva(page);
        uintptr_t kva_dst = page2kva(npage);
        memcpy(kva_dst, kva_src, PGSIZE);
        ret=page_insert(to, npage, start, perm);
        assert(ret == 0);
	...
}
```
使用到的函数：
`page2kva(struct Page *page)`：返回kernel vritual addr

***
## 练习3

阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现。

### `fork`（实际上的函数为`do_fork`）

- 分配并初始化进程控制块`alloc_proc`;
- 分配并初始化内核栈`setup_stack`;
- 根据`clone_flag`标志复制或共享进程内存管理结构`copy_mm`;
- 设置进程在内核正常运行和调度所需的中断帧tf和上下文`copy_thread`;
- 调用`get_pid()`为进程分配一个PID;
- 把设置好的进程控制块加入`hash_list`和`proc_list`两个全局进程链表中;
- 返回进程的PID。

核心代码如下：
```c
    if ((proc = alloc_proc()) == NULL)
        goto fork_out;
    proc->parent = current;
    if ((ret = setup_kstack(proc)) != 0)
        goto fork_out;
    if ((ret = copy_mm(clone_flags, proc)) != 0)
        goto fork_out;
    copy_thread(proc, stack, tf);
    ret = proc->pid = get_pid();
    hash_proc(proc);//建立哈希映射
    set_links(proc);//设置进程链接
    wakeup_proc(proc);//唤醒新进程
```

### `exec`（实际上的函数为`do_execve`）

- 检查进程名称的地址和长度是否合法，如果合法，将名称暂时保存在函数栈中;
- 如果mm不为NULL：
    - 设置页表为内核空间页表;
    - 判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。
    - 最后把当前进程的mm内存管理指针为空。
- 将代码加载进内存`load_icode`;
- 设置进程名称`set_proc_name`。

代码如下：
```c
int
do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {
    struct mm_struct *mm = current->mm;
    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {
        return -E_INVAL;
    }
    if (len > PROC_NAME_LEN) {
        len = PROC_NAME_LEN;
    }

    char local_name[PROC_NAME_LEN + 1];
    memset(local_name, 0, sizeof(local_name));
    memcpy(local_name, name, len);

    if (mm != NULL) {
        lcr3(boot_cr3);
        if (mm_count_dec(mm) == 0) {
            exit_mmap(mm);
            put_pgdir(mm);
            mm_destroy(mm);
        }
        current->mm = NULL;
    }
    int ret;
    if ((ret = load_icode(binary, size)) != 0) {
        goto execve_exit;
    }
    set_proc_name(current, local_name);
    return 0;

execve_exit:
    do_exit(ret);
    panic("already exit: %e.\n", ret);
}
```