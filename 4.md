# Lab4 Report
函数调用关系图
![2](picture/4-1.jpg "4-1.jpg")
PCB数据结构
```c
struct proc_struct {
    enum proc_state state; // Process state
    int pid; // Process ID
    int runs; // the running times of Proces
    uintptr_t kstack; // Process kernel stack
    volatile bool need_resched; // need to be rescheduled to release CPU?
    struct proc_struct *parent; // the parent process
    struct mm_struct *mm; // Process's memory management field
    struct context context; // Switch here to run process
    struct trapframe *tf; // Trap frame for current interrupt
    uintptr_t cr3; // the base addr of Page Directroy Table(PDT)
    uint32_t flags; // Process flag
    char name[PROC_NAME_LEN + 1]; // Process name
    list_entry_t list_link; // Process link list
    list_entry_t hash_link; // Process hash list
}
```
| 字段名       | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| `state`      | 进程所处状态|
| `pid`        | 进程ID|
| `kstack`     | 进程内核栈地址。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。|
| `parent`     | 父进程 |
| `mm`         | 内存管理的信息，包括内存映射列表、页表指针等|
| `context`    | 进程的上下文，用于进程切换|
| `tf`         | 中断帧的指针，记录了进程在被中断前的状态|
| `cr3`        |cr3 保存页表的物理地址，但是当为内核线程时，内核线程没有用户空间，cr3 等于boot_cr3，boot_cr3指向了uCore启动时建立好的内核虚拟空间的页目录表首地址。|

## 练习1 
**分配并初始化一个进程控制块**
alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
```c
static struct proc_struct *
alloc_proc(void) {
      struct proc_struct *proc = kmalloc(sizeof(struct  
                                         proc_struct));
      if (proc != NULL) {
          proc->state = PROC_UNINIT; //进程为未初始化状态，枚举类型在.c中定义
          proc->pid = -1;            //进程PID为-1，即未分配有效pid
          proc->runs = 0;            //运行次数0
          proc->kstack = 0;          //内核栈地址，未分配
          proc->need_resched = 0;    //不需要调度
          proc->parent = NULL;       //父进程为空
          proc->mm = NULL;           //虚拟内存为空
          memset(&(proc->context), 0, sizeof(struct 
                 context));          //初始化上下文，分配空间
          proc->tf = NULL;           //中断帧指针为空，还没有分配
          proc->cr3 = boot_cr3;      //页目录为内核页目录表的地址
          proc->flags = 0;           //标志位为0
          memset(proc->name, 0, PROC_NAME_LEN);//进程名为0
    }
    return proc;
}
```
> 请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

context的就是进程上下文，即进程执行时各寄存器的取值。用于进程切换时保存进程上下文比如本实验中，当idle进程被CPU切换出去时，可以将idle进程上下文保存在其proc_struct结构体的context成员中，这样当CPU运行完init进程，再次运行idle进程时，能够恢复现场，继续执行。
tf是中断帧的指针，总是指向内核栈的某个位置。tf变量作用于在构造了新的线程的时候，如果要将控制权转交给这个线程，需要使用中断返回的方式进行（与lab1的切换特权级类似），因此需要构造一个伪造的中断返回现场，也就是trapframe（保存着用于特权级转换的栈esp寄存器，进程发生特权级转换时中断帧记录进入中断时任务的上下文），使得可以正确的将控制权转交给新的线程；

## 练习2 
**为新创建的内核线程分配资源**
创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：

+ 调用alloc_proc，首先获得一块用户信息块。（即调用练习1写的函数）
+ 为进程分配一个内核栈。 即kstack
+ 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
+ 复制原进程上下文到新进程
+ 将新进程添加到进程列表
+ 唤醒新进程
+ 返回新进程号

用到的函数和变量
| 步骤 | 描述 |
| --- | --- |
| `alloc_proc` | 创建一个 `proc_struct` 并初始化字段|
| `setup_kstack` | 为子进程分配内核栈（大小为 `KSTACKPAGE`） |
| `copy_mm` | 根据 `clone_flags` 复制或共享父进程的内存管理结构，如果 `clone_flags & CLONE_VM`，则“共享”；否则“复制” |
| `copy_thread` | 设置进程的陷入帧（`tf`）和上下文 |
| `hash_proc` | 将 `proc_struct` 插入哈希表和进程列表 |
| `get_pid` | 为进程分配一个唯一的进程 ID |
| `wakeup_proc` | 将新的子进程设置为可运行状态 |
| **变量** | **描述** |
| `proc_list` | 进程集合的列表 |
| `nr_process` | 进程集合中的进程数量 |


|步骤	|描述|
|-|---------------|
|1	|调用 alloc_proc 分配一个 proc_struct|
|2|	调用 setup_kstack 为子进程分配内核栈|
|3|	根据 clone_flag 调用 copy_mm 来复制或共享内存管理结构|
|4|	调用 copy_thread 设置 tf 和进程上下文|
|5|	将 proc_struct 插入哈希表和进程列表|
|6|	调用 wakeup_proc 使新的子进程变为可运行状态|
|7|	使用子进程的进程 ID 设置返回值|

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    proc=alloc_proc();
    if(!proc)goto bad_fork_cleanup_proc;//分配PCB失败
    else
    {
        if(setup_kstack(proc)!=0)goto bad_fork_cleanup_kstack;//分配内核栈失败
        copy_mm(clone_flags,proc);//根据clone_flags设置mm
        copy_thread(proc,stack,tf);//设置trapframe和context
        proc->pid=get_pid();//分配pid
        hash_proc(proc);//加入hash_list
        list_add(&proc_list, &(proc->list_link));//加入proc_list
        nr_process++;//总进程数加1
        wakeup_proc(proc); // 唤醒当前进程
        ret=proc->pid;//返回进程号
    }
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```
> 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

可以在do_fork中看到pid是通过get_pid()分配的：proc->pid=get_pid();
线程的 PID 由 get_pid 函数产生，该函数中包含了两个静态变量 last_pid 以及 next_safe。last_pid 变量保存上一次分配的 PID，而 next_safe 和 last_pid 一起表示一段可以使用的 PID 取值范围  ，last_pid 和 next_safe 被初始化为 MAX_PID。每次调用 get_pid 时，除了确定一个可以分配的 PID 外，还需要确定 next_safe 来实现均摊以此优化时间复杂度，PID 的确定过程中会检查所有进程的 PID，来确保 PID 是唯一的。
```c
// get_pid - alloc a unique pid for process
static int
get_pid(void) {
    //定义了MAX_PID=2*MAX_PROCESS，意味着ID的总数目是大于PROCESS的总数目的,因此不会出现部分PROCESS无ID可分的情况
    static_assert(MAX_PID > MAX_PROCESS);
    struct proc_struct *proc;
    list_entry_t *list = &proc_list, *le;
    static int next_safe = MAX_PID, last_pid = MAX_PID;
    if (++ last_pid >= MAX_PID) 
    {
        last_pid = 1;
        goto inside;
    }
    if (last_pid >= next_safe) 
    {
    inside:
        next_safe = MAX_PID;
    repeat:
        //le等于线程的链表头
        le = list;      
        //循环扫描每一个当前进程：当一个现有的进程号和last_pid相等时，则将last_pid+1；
        while ((le = list_next(le)) != list) 
        { 
            proc = le2proc(le, list_link);
            //如果proc的pid与last_pid相等，则将last_pid加1
            //当然，如果last_pid>=MAX_PID,then 将其变为1
            //确保了没有一个进程的pid与last_pid重合
            if (proc->pid == last_pid) 
            {
                if (++ last_pid >= next_safe) 
                {
                    if (last_pid >= MAX_PID) 
                    {
                        last_pid = 1;
                    }
                    next_safe = MAX_PID;
                    goto repeat;
                }
            }
            else if (proc->pid > last_pid && next_safe > proc->pid) 
            {
                next_safe = proc->pid;
            }
        }
    }
    return last_pid;
}
```

## 练习3
**阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。**
```c
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            load_esp0(next->kstack + KSTACKSIZE);
            lcr3(next->cr3);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```
**理解：**
准备知识：参数struct proc_struct *proc为要调度运行的进程PCB,current为全局变量，保存着当前运行的进程PCB
1. 首先通过判断proc != current来保证当前运行的和要运行的不是一个进程
2. intr_flag，用于屏蔽中断
3. struct proc_struct *prev = current, *next = proc;将prev指向目前运行的进程，next指向要调度的进程，方便后续进行切换
4. local_intr_save(intr_flag);关中断，避免中断干扰
5.  进行切换，过程如下：
    current = proc;将current指向要调度运行的进程
    load_esp0(next->kstack + KSTACKSIZE);加载待调度进程的内核栈基地址
    lcr3(next->cr3);更换页表
    switch_to(&(prev->context), &(next->context));上下文切换
6.  local_intr_restore(intr_flag);关中断

> 在本实验的执行过程中，创建且运行了几个内核线程？
语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由

总共创建了两个内核线程，分别为：
1. idle_proc，为第 0 个内核线程，在完成新的内核线程的创建以及各种初始化工作之后，进入死循环，用于调度其他进程或线程；(**proc_init中创建**)
2. init_proc，被创建用于打印 "Hello World" 的线程。本次实验的内核线程，只用来打印字符串。（**kernel_thread中创建**）

local_intr_save(intr_flag);....local_intr_restore(intr_flag);用于**关中断**，在准备切换进程的时候，需要重新设置栈和页表，并且需要切换进程上下文，如果不关中断，进程信息设置到一半的时候很可能会被中断打断，导致寄存器状态处于一个不一致的状态，造成程序运行出错。
## 结果
![1](picture/4-result.png "4-result.png")