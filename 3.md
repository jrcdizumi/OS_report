# Lab3 Report

***
## 练习1

**给未被映射的地址映射上物理页：**

先检查页表中是否有该地址对应的表项。若表项为空则未被映射。
对未被映射的地址，使用`pgdir_alloc_page`函数获取物理页。
```c
    ptep = get_pte(mm->pgdir, addr, 1);
    if(ptep == NULL) {
        cprintf("get_pte failed\n");
        goto failed;
    }
    if (*ptep == 0) {
        struct Page *page = pgdir_alloc_page(mm->pgdir, addr, perm);
        if (page == NULL){
            cprintf("pgdir_alloc_page failed\n");
            goto failed;            
        }
    }
```
![1](picture/3-1.png "3-1.png")
经验证，能够通过check_pgfault函数的测试。

- Q1. 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

    `PTE_A`表示是否被访问，`PTE_D`表示是否被修改，对Clock算法、Enhanced Clock算法和LRU算法有潜在用处。

- Q2. 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
    
    硬件将引发页访问异常的地址保存在cr2寄存器中，设置错误代码，然后触发Page Fault异常。

***
## 练习2

**补充完成基于FIFO的页面替换算法：**

如果PTE存在，那么说明这一页已被映射但是被保存在磁盘中，需要将这一页内存交换出来。
根据
    ![2](picture/3-2.png "3-2.png")
    先调用`swap_in`将内存页从磁盘中载入内存；
    调用`page_insert`建立物理地址与线性地址之间的映射；
    设置页对应的虚拟地址，方便交换出内存时将正确的内存数据保存在正确的磁盘位置；
    调用`swap_map_swappable`将物理页框加入FIFO。

`do_pgfault`函数：
```c
        if(swap_init_ok) {
            struct Page *page = NULL;
            //(1）According to the mm AND addr, try to load the content of right disk page
            //    into the memory which page managed.
            swap_in(mm, addr, &page);
            //(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
            page_insert(mm->pgdir, page, addr, perm);
            //(3) make the page swappable.
            page->pra_vaddr = addr;
            swap_map_swappable(mm, addr, page, 0);
        }
        else {
            cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
            goto failed;
        }
```
